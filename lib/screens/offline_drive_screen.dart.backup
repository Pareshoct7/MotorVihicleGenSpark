import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/material.dart';
import 'package:share_plus/share_plus.dart';
import 'package:printing/printing.dart';
import 'package:intl/intl.dart';

import '../services/offline_drive_service.dart';

class OfflineDriveScreen extends StatefulWidget {
  final Directory? initialDirectory;

  const OfflineDriveScreen({super.key, this.initialDirectory});

  @override
  State<OfflineDriveScreen> createState() => _OfflineDriveScreenState();
}

class _OfflineDriveScreenState extends State<OfflineDriveScreen> {
  Directory? _currentDir;
  List<FileSystemEntity> _contents = [];
  bool _isLoading = true;
  bool _isBackfilling = false;

  @override
  void initState() {
    super.initState();
    _initializeDirectory();
  }

  Future<void> _initializeDirectory() async {
    final rootDir = widget.initialDirectory ?? await OfflineDriveService.getRootDirectory();
    if (mounted) {
      setState(() {
        _currentDir = rootDir;
      });
      _loadContents();
    }
  }

  Future<void> _loadContents() async {
    final currentDir = _currentDir;
    if (currentDir == null) return;
    
    setState(() => _isLoading = true);
    try {
      final rootDir = await OfflineDriveService.getRootDirectory();
      if (rootDir.path == currentDir.path) {
          // Special case: if root, ensure sync happens first to show stores
          await OfflineDriveService.syncStructure();
      }
      final items = await OfflineDriveService.getContents(currentDir);
      if (mounted) {
        setState(() {
          _contents = items;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error loading folder: $e')),
        );
      }
    }
  }

  void _navigateTo(Directory dir) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => OfflineDriveScreen(initialDirectory: dir),
      ),
    );
  }

  Future<void> _openFile(File file) async {
    // Open file using open_file package or share it
    // Using share_plus is safer for now as specific viewers might not be installed
    // But let's try opening first.
    // 'open_file' package is not in pubspec based on my previous view.
    // 'url_launcher' is there. 'share_plus' is there.
    // Let's just Share the file.
    
    final xFile = XFile(file.path);
    await Share.shareXFiles([xFile], text: 'Inspection Report');
  }

  Future<void> _runBackfill() async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sync & Backfill Drive'),
        content: const Text(
          'This will scan for missing reports (last 1 year) and generate them automatically if they don\'t exist.\n\nThis may take a minute.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Start'),
          ),
        ],
      ),
    );

    if (confirm != true) return;

    setState(() => _isBackfilling = true);

    // Show persistent status via dialog or bottom sheet? 
    // Let's use a Progress Dialog
    if (!mounted) return;
    
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) {
        return StatefulBuilder(
          builder: (context, setStateDialog) {
            return AlertDialog(
              title: const Text('Syncing...'),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                   const LinearProgressIndicator(),
                   const SizedBox(height: 16),
                   // We can't easily stream status out to this dialog without a Stream or ValueNotifier.
                   // The callback is outside.
                   // Simple generic message for now.
                   const Text('Processing vehicle history...'),
                ],
              ),
            );
          }
        );
      },
    );

    try {
      await OfflineDriveService.generateAllBackfill(
        onProgress: (completed, total, status) {
          // Log or update generic status
          debugPrint('$status ($completed/$total)');
        },
      );
      
      if (mounted) {
        Navigator.pop(context); // Close Status Dialog
        _loadContents(); // Refresh current view
        ScaffoldMessenger.of(context).showSnackBar(
           const SnackBar(content: Text('Drive Sync Completed!')),
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.pop(context); // Close Status Dialog
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error during sync: $e')),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isBackfilling = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_currentDir == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Offline Drive')),
        body: const Center(child: CircularProgressIndicator()),
      );
    }
    
    final folderName = _currentDir!.path.split('/').last.isEmpty 
        ? 'Offline Drive' 
        : _currentDir!.path.split('/').last;

    return Scaffold(
      appBar: AppBar(
        title: Text(folderName),
        backgroundColor: Theme.of(context).colorScheme.surfaceVariant,
        actions: [
          // Show sync button on what appears to be root (OfflineDrive folder)
          if (folderName == 'Offline Drive' || folderName == 'OfflineDrive')
            IconButton(
              icon: const Icon(Icons.sync),
              onPressed: _isBackfilling ? null : _runBackfill,
              tooltip: 'Sync & Backfill',
            ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : _contents.isEmpty
              ? const Center(child: Text('Empty Folder'))
              : ListView.builder(
                  itemCount: _contents.length,
                  itemBuilder: (context, index) {
                    final item = _contents[index];
                    final name = item.path.split('/').last;
                    final isDir = item is Directory;

                    return ListTile(
                      leading: Icon(
                        isDir ? Icons.folder : Icons.picture_as_pdf,
                        color: isDir ? Colors.amber : Colors.red,
                        size: 32,
                      ),
                      title: Text(name),
                      trailing: isDir ? const Icon(Icons.chevron_right) : null,
                      onTap: () {
                        if (isDir) {
                          _navigateTo(item as Directory);
                        } else {
                          _openFile(item as File);
                        }
                      },
                    );
                  },
                ),
    );
    );      floatingActionButton: _isLoading || _contents.isEmpty || _currentDir == null
          ? null
          : FloatingActionButton.extended(
              onPressed: _combinePdfs,
              icon: const Icon(Icons.picture_as_pdf),
              label: const Text('Combine PDFs'),
              tooltip: 'Combine all PDFs in this folder',
            ),
    );
  }
  Future<void> _combinePdfs() async {
    final currentDir = _currentDir;
    if (currentDir == null) return;
    
    final confirm = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Combine PDFs'),
        content: const Text(
          'This will combine all PDFs in this folder and its subfolders into a single PDF.\n\nContinue?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Combine'),
          ),
        ],
      ),
    );

    if (confirm != true) return;
    if (!mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const AlertDialog(
        title: Text('Combining PDFs...'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            LinearProgressIndicator(),
            SizedBox(height: 16),
            Text('Processing PDFs...'),
          ],
        ),
      ),
    );

    try {
      final pdfBytes = await OfflineDriveService.generateClubbedPdfFromFolder(
        folder: currentDir,
        onProgress: (c, t) {
          debugPrint('Progress: $c / $t');
        },
      );

      if (mounted && pdfBytes != null) {
        Navigator.pop(context);

        final folderName = currentDir.path.split('/').last;
        final timestamp = DateFormat('yyyyMMdd_HHmm').format(DateTime.now());
        final filename = 'Clubbed_${_sanitizeName(folderName)}_$timestamp.pdf';

        await Printing.sharePdf(bytes: pdfBytes, filename: filename);

        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('PDFs combined successfully!')),
        );
      }
    } catch (e) {
      if (mounted) {
        Navigator.pop(context);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  String _sanitizeName(String input) {
    return input.replaceAll(RegExp(r'[<>:"/\\|?*]'), '_').trim();
  }
}
